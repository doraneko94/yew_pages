= Hello, Yew!

== 最も簡単なWebアプリ

新しい技術の最初の一歩を踏み出すときには、"Hello, World!"を実行することが慣例です。ここでは、「Hello, Yew!」の文字列を表示するだけのWebアプリを作成し、Github Pagesで公開するための基本を学びます。このWebアプリのサンプルは、以下のURLで公開されています。

//blankline
[外部リンク] Hello, Yew!

@<href>{https://j-impact.github.io/hello-yew/}
//blankline

文字を表示するだけでも立派なWebアプリです。このWebアプリを作るためのコード一式は、以下のリポジトリにまとめています。

//blankline
[外部リンク] J-IMPACT/hello-yew

@<href>{https://github.com/J-IMPACT/hello-yew}
//blankline

== 作業の進め方

以降の章では、このリポジトリに含まれるファイルの内容を１つずつ解説することで、Github PagesでWebアプリを公開するための最小構成を学習します。実際に作業を行いながら本書を読み進める場合には、以下の2通りの方法を推奨します。

//caution{
ただし、どの方法を選択する場合あっても、Githubアカウントが作成済みであり、自身のPCで@<code>{git}コマンドが使用可能になっていることを前提とします。
@<code>{git}コマンドが使用できない場合には、Gitの公式サイト@<href>{https://git-scm.com/}を参照してインストールしてください。
//}

=== 空のプロジェクトを作って、必要なファイルを再現する

Rustで空のプロジェクトを作成し、その中に@<code>{J-IMPACT/hello-yew}内のファイルを作成しながらリポジトリを再現します。コードの写経を通して理解度を高めたい読者におすすめの方法です。コードを写し間違えるとWebアプリが動作しなくなることがあるため注意が必要ですが、動作に不具合がある場合のバグ修正も含めて、非常に実践的な経験を積むことができると思います。

この方法で作業を進める場合には、シェルやコマンドプロンプトでRustプロジェクトを作成したいディレクトリ（フォルダ）に移動し、@<list>{cargo_new}のコマンドで、@<code>{hello-yew}という名前の空のRustプロジェクトを作成します。

//list[cargo_new][Rustプロジェクトの新規作成: shell]{
> cargo new hello-yew
//}

すると@<code>{hello-yew}ディレクトリが作成され、その中にRustで開発を行うための必要最小限のファイルが生成されます。この@<code>{hello-yew}ディレクトリをVS Codeなどのエディタで開き、各ファイルの内容が@<code>{J-IMPACT/hello-yew}と同じになるようにコードを修正してください。

//blankline
[外部リンク] Visual Studio Code（参考）

@<href>{https://code.visualstudio.com/}

//info{
いくつかのファイルは新規に作成する必要があります。

ただし、@<code>{Cargo.lock}ファイルは無視し、@<b>{複製も削除もしないでください}。このファイルはRustのビルド時に、そのときのクレートの状況に合わせて自動で生成されますが、Webアプリ全体の動作に影響を与えません。
//}

//caution{
また、@<code>{J-IMPACT/hello-yew}に含まれていないからといって、@<list>{cargo_new}の実行直後から存在する@<code>{.git}ディレクトリは@<b>{絶対に削除しないでください}。このディレクトリはGitならびにGithubでのプロジェクト管理に極めて重要です。

なお、@<code>{.git}ディレクトリは隠しフォルダに設定されているため、PCの設定によっては見えない場合があります。
//}

この方法を採用した場合には、新規作成した@<code>{hello-yew}ディレクトリと、読者のGithubリポジトリを結びつける作業が必要です。（作業内容は後ほど解説します）

=== リポジトリをフォークする

コードを写経することに意味を感じない、またはサッと一通り本書を読み終えてしまいたい読者にはこちらの方法をおすすめします。

Githubにおけるリポジトリの「@<b>{フォーク}」とは、他のユーザが作成したリポジトリを自分のアカウントにコピーすることを意味します。コピー元のリポジトリを「本家」とし、自身のアカウントの管理下に「分家」を作成するイメージです。具体的には、本章の「Hello, Yew!」リポジトリは「J-IMPACT」のアカウントで作成したため@<code>{J-IMPACT/hello-yew}という名前になっていますが、これをフォークすることで@<code>{[your-user-name]/hello-yew}が作成されます。

フォークの方法は非常に簡単で、Githubにログインした状態で@<img>{fork_button}に示した「Fork」ボタンをクリックするだけです（なお、Fork」ボタンをクリックする前に、その右横にある「Star」ボタンも押していただけると著者が泣いて喜びます）。

//image[fork_button][「Fork」ボタンの位置]

すると@<img>{create_fork}のような画面が表示されるので、「Create fork」ボタンをクリックするとフォークが完了し、あなたのアカウントの管理下に置かれた@<code>{[your-user-name]/hello-yew}リポジトリのページに遷移します。

//image[create_fork][「Create fork」ボタンの位置]

//info{
@<code>{J-IMPACT/hello-yew}と@<code>{[your-user-name]/hello-yew}の内容は独立しています。よって、分家であるあなたの@<code>{hello-yew}の内容を変更しても、本家のリポジトリの内容には影響を与えません。
//}

この@<code>{[your-user-name]/hello-yew}を使って作業を行うため、リポジトリの内容を自身のPCにコピーしておきます。シェルやコマンドプロンプトでリポジトリのコピーを作成したいディレクトリ（フォルダ）に移動し、@<list>{git_clone}のコマンドでリポジトリを@<b>{クローン}してください（@<code>{[your-user-name]}は、あなたのアカウント名で置き換えてください。カッコ@<code>{[]}は削除してください。つまり、この部分はあなたのリポジトリのURLに相当します）。

//list[git_clone][リポジトリのクローン: shell]{
> git clone https://github.com/[your-user-name]/hello-yew
//}

== 各ファイルの解説

ここからは、各ファイルの役割と内容を解説します。

=== @<code>{Cargo.toml}

@<code>{Cargo.toml}はRustプロジェクトに関する様々な設定を記述するファイルです。設定の中でも特に重要なのが、使用するクレートを宣言する@<code>{[dependencies]}の項目です。@<list>{dependencies}にこの部分を表示します。

//list[dependencies][dependenciesの内容: Cargo.toml]{
[dependencies]
yew = { version = "0.21.0", features = ["csr"] }
//}

ここでは@<code>{yew}クレートのみを使用することを宣言しています。@<code>{version = "0.21.0"}は、これまで数多くリリースされた@<code>{yew}クレートの中でも、バージョン0.21.0を使用することを指定しています。異なるバージョンのクレートを使用するとビルドに失敗する場合があるため、指定するバージョンを吟味することは非常に重要です。

@<code>{features}では、@<code>{yew}クレートを使用する際のモード（feature）を指定しています。featureは配列として複数指定することができるため、feature"s"となっています。featureの指定を切り替えることによって、クレートが提供する関数や構造体の内容を変化させることができます。

ここで指定している@<code>{csr}は、@<b>{Client Side Rendering}を意味しています。これと対になるのが@<b>{Server Side Rendering}（SSR）です。レンダリング（Rendering）とは、コンピュータがデータを処理し、HTML等による描画を行う処理のことです。つまり、「画面に何をどう表示するか」を決定する処理です。

以下、「幅がX、高さがYの平行四辺形の面積を計算するWebアプリ」を例に、SSRとCSRの動作の違いを説明します。

==== Server Side Rendering (SSR)

Webアプリにアクセスし、これを利用するユーザのことを@<b>{クライアント}といいます。対して、Webアプリの提供元を@<b>{サーバ}といいます。

SSRは、レンダリングをサーバ側で行う方式です。たとえばクライアントがWebアプリのフォームに「X=3, Y=4」と入力して「計算」ボタンを押したとします。SSRではこの入力内容が@<b>{リクエスト}としてサーバに送られ、サーバでは「3×4=12」という計算を実行します。

そして計算結果「12」を含むHTMLが生成され、それが@<b>{レスポンス}としてクライアントに返送されます。その結果、クライアントのブラウザに「面積は12です」と表示されます。

つまりSSRでは、計算と描画を@<b>{サーバ側で実行}し、結果だけをクライアントに送る構造になっています。そのため、処理速度はサーバの性能に依存します。

==== Client Side Rendering (CSR)

CSRは、レンダリングをクライアント側、つまりブラウザの中で行う方式です。この場合、クライアントがWebアプリにアクセスした時点で、サーバからHTMLやCSS、WASMなどの@<b>{アプリケーションのロジック}を含むファイル一式が送られます。この中には、

「幅がX、高さがYの平行四辺形の面積を求めたかったら、X×Yを計算してね」

という指示がすでに組み込まれています。

CSRでは、クライアントがフォームに「X=3, Y=4」と入力した情報はサーバには送信されません。その代わりにクライアント側のブラウザ内で、すでに送られてきている指示に従って「3×4=12」という計算を実行し、結果の「12」という文字を画面に表示します。

つまりCSRでは、計算と描画を@<b>{クライアント側で実行}します。そのため、処理速度はユーザの端末性能に依存しますが、一度ファイルを読み込めばページ遷移や操作が高速に行えるという利点もあります。

==== 本書における基本戦略

実装したいWebアプリの機能によって、SSR・CSRそれぞれに向き・不向きがあると考えられます。そのため、可能であればこれらを組み合わせて使用したいところです。しかし、静的ホスティングサーバであるGithub Pagesでは、サーバでの処理を実行できないためSSRは採用できません。よって、Github Pagesは以下のようなWebアプリを提供する用途には適していないことがわかります。

 1. サーバの高性能な計算機能を提供するWebアプリ（物理シミュレータなど）
 2. レンダリング時に、クライアントに秘匿すべき情報が必要となるWebアプリ（ログイン処理など）

これら以外のWebアプリの機能は、CSRでも十分に実装することができます。また、1.のように「高機能なサーバ処理」を提供することはできませんが、「高速なバイナリ（WASM）」や「高機能なアルゴリズム」を提供して、有用な物理シミュレータを作ることは可能です（ログイン処理に関しては、Webアプリへのアクセス時に全ユーザ名とパスワードをクライアントに送信してしまえば原理上は実装可能ですが、セキュリティの観点から現実的ではありません）。

本書では、CSRで実装可能な機能を数多く紹介し、それらを組み合わせて有意義なWebアプリをGithub Pages上で公開することを基本戦略とします。

=== @<code>{src/main.rs}

@<code>{src}ディレクトリにはRustのソースコードが格納されます。
その中で、@<code>{main.rs}がWebアプリの動作を定義する核となっています。

ここでは、@<code>{main.rs}の内容を解説しながらRustならびにYewの使い方を解説します。

==== クレート使用の宣言

//list[use_yew][yewクレートの使用を宣言: src/main.rs]{
use yew::prelude::*;
//}

@<list>{use_yew}では@<code>{yew}クレートを使用することを宣言しています。
@<code>{prelude}は、@<code>{yew}クレートの中でも頻繁に利用される機能の一覧です。
つまり@<list>{use_yew}の1行は、「@<code>{yew}クレートの頻繁に利用される機能（@<code>{prelude}）のすべて（@<code>{*}）を使用する」ことを宣言しています。

==== コンポーネントの定義

Yewを使う主な目的は、描画する@<b>{コンポーネント}を定義することです。コンポーネントとは、複数のHTML要素・CSS・JavaScriptをまとめた再利用可能な単位

//list[def_app][]{
#[function_component(App)]
fn app() -> Html {
    html! {
        <h1>{ "Hello, Yew!" }</h1>
    }
}
//}