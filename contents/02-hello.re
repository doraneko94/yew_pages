= Hello, Yew!

== 最も簡単なWebアプリ

新しい技術の最初の一歩を踏み出すときには、"Hello, World!"を実行することが慣例です。ここでは、「Hello, Yew!」の文字列を表示するだけのWebアプリを作成し、Github Pagesで公開するための基本を学びます。このWebアプリのサンプルは、以下のURLで公開されています。

//blankline
[外部リンク] Hello, Yew!

@<href>{https://j-impact.github.io/hello-yew/}
//blankline

文字を表示するだけでも立派なWebアプリです。このWebアプリを作るためのコード一式は、以下のリポジトリにまとめています。

//blankline
[外部リンク] J-IMPACT/hello-yew

@<href>{https://github.com/J-IMPACT/hello-yew}
//blankline

== 作業の進め方

以降の章では、このリポジトリに含まれるファイルの内容を１つずつ解説することで、Github PagesでWebアプリを公開するための最小構成を学習します。実際に作業を行いながら本書を読み進める場合には、以下の2通りの方法を推奨します。

//caution{
ただし、どの方法を選択する場合あっても、Githubアカウントが作成済みであり、自身のPCで@<code>{git}コマンドが使用可能になっていることを前提とします。
@<code>{git}コマンドが使用できない場合には、Gitの公式サイト@<href>{https://git-scm.com/}を参照してインストールしてください。
//}

=== 空のプロジェクトを作って、必要なファイルを再現する

Rustで空のプロジェクトを作成し、その中に@<code>{J-IMPACT/hello-yew}内のファイルを作成しながらリポジトリを再現します。コードの写経を通して理解度を高めたい読者におすすめの方法です。コードを写し間違えるとWebアプリが動作しなくなることがあるため注意が必要ですが、動作に不具合がある場合のバグ修正も含めて、非常に実践的な経験を積むことができると思います。

この方法で作業を進める場合には、シェルやコマンドプロンプトでRustプロジェクトを作成したいディレクトリ（フォルダ）に移動し、@<list>{cargo_new}のコマンドで、@<code>{hello-yew}という名前の空のRustプロジェクトを作成します。

//list[cargo_new][Rustプロジェクトの新規作成: shell]{
> cargo new hello-yew
//}

すると@<code>{hello-yew}ディレクトリが作成され、その中にRustで開発を行うための必要最小限のファイルが生成されます。この@<code>{hello-yew}ディレクトリをVS Codeなどのエディタで開き、各ファイルの内容が@<code>{J-IMPACT/hello-yew}と同じになるようにコードを修正してください。

//blankline
[外部リンク] Visual Studio Code（参考）

@<href>{https://code.visualstudio.com/}

//info{
いくつかのファイルは新規に作成する必要があります。

ただし、@<code>{Cargo.lock}ファイルは無視し、@<b>{複製も削除もしないでください}。このファイルはRustのビルド時に、そのときのクレートの状況に合わせて自動で生成されますが、Webアプリ全体の動作に影響を与えません。
//}

//caution{
また、@<code>{J-IMPACT/hello-yew}に含まれていないからといって、@<list>{cargo_new}の実行直後から存在する@<code>{.git}ディレクトリは@<b>{絶対に削除しないでください}。このディレクトリはGitならびにGithubでのプロジェクト管理に極めて重要です。

なお、@<code>{.git}ディレクトリは隠しフォルダに設定されているため、PCの設定によっては見えない場合があります。
//}

この方法を採用した場合には、新規作成した@<code>{hello-yew}ディレクトリと、読者のGithubリポジトリを結びつける作業が必要です。（作業内容は後ほど解説します）

=== リポジトリをフォークする

コードを写経することに意味を感じない、またはサッと一通り本書を読み終えてしまいたい読者にはこちらの方法をおすすめします。

Githubにおけるリポジトリの「@<b>{フォーク}」とは、他のユーザが作成したリポジトリを自分のアカウントにコピーすることを意味します。コピー元のリポジトリを「本家」とし、自身のアカウントの管理下に「分家」を作成するイメージです。具体的には、本章の「Hello, Yew!」リポジトリは「J-IMPACT」のアカウントで作成したため@<code>{J-IMPACT/hello-yew}という名前になっていますが、これをフォークすることで@<code>{[your-user-name]/hello-yew}が作成されます。

フォークの方法は非常に簡単で、Githubにログインした状態で@<img>{fork_button}に示した「Fork」ボタンをクリックするだけです（なお、Fork」ボタンをクリックする前に、その右横にある「Star」ボタンも押していただけると著者が泣いて喜びます）。

//image[fork_button][「Fork」ボタンの位置]

すると@<img>{create_fork}のような画面が表示されるので、「Create fork」ボタンをクリックするとフォークが完了し、あなたのアカウントの管理下に置かれた@<code>{[your-user-name]/hello-yew}リポジトリのページに遷移します。

//image[create_fork][「Create fork」ボタンの位置]

//info{
@<code>{J-IMPACT/hello-yew}と@<code>{[your-user-name]/hello-yew}の内容は独立しています。よって、分家であるあなたの@<code>{hello-yew}の内容を変更しても、本家のリポジトリの内容には影響を与えません。
//}

この@<code>{[your-user-name]/hello-yew}を使って作業を行うため、リポジトリの内容を自身のPCにコピーしておきます。シェルやコマンドプロンプトでリポジトリのコピーを作成したいディレクトリ（フォルダ）に移動し、@<list>{git_clone}のコマンドでリポジトリを@<b>{クローン}してください（@<code>{[your-user-name]}は、あなたのアカウント名で置き換えてください。カッコ@<code>{[]}は削除してください。つまり、この部分はあなたのリポジトリのURLに相当します）。

//list[git_clone][リポジトリのクローン: shell]{
> git clone https://github.com/[your-user-name]/hello-yew
//}

== 各ファイルの解説

ここからは、各ファイルの役割と内容を解説します。

=== Cargo.toml

@<code>{Cargo.toml}はRustプロジェクトに関する様々な設定を記述するファイルです。設定の中でも特に重要なのが、使用するクレートを宣言する@<code>{[dependencies]}の項目です。@<list>{dependencies}にこの部分を表示します。

//list[dependencies][dependenciesの内容: Cargo.toml]{
[dependencies]
yew = { version = "0.21.0", features = ["csr"] }
//}

ここでは@<code>{yew}クレートのみを使用することを宣言しています。@<code>{version = "0.21.0"}は、これまで数多くリリースされた@<code>{yew}クレートの中でも、バージョン0.21.0を使用することを指定しています。異なるバージョンのクレートを使用するとビルドに失敗する場合があるため、指定するバージョンを吟味することは非常に重要です。

@<code>{features}では、@<code>{yew}クレートを使用する際のモード（feature）を指定しています。featureは配列として複数指定することができるため、feature"s"となっています。featureの指定を切り替えることによって、クレートが提供する関数や構造体の内容を変化させることができます。

ここで指定している@<code>{csr}は、@<b>{Client Side Rendering}を意味しています。これと対になるのが@<b>{Server Side Rendering}（SSR）です。レンダリング（Rendering）とは、コンピュータがデータを処理し、描画を行うプロセスのことです。以下、「幅がX、高さがYの平行四辺形の面積を計算するWebアプリ」を例に、これらのレンダリング方式の違いを説明します。

==== Server Side Rendering (SSR)

Webアプリにアクセスし、これを利用するユーザのことを@<b>{クライアント}といいます。対して、Webアプリの情報を保持している提供元を@<b>{サーバ}といいます。

SSRは、レンダリングをサーバ側で行う方式のことです。たとえばクライアントがWebアプリのフォームに「X=3, Y=4」と入力した場合、SSRではこれが@<b>{リクエスト}としてサーバに送られます。そしてサーバで「3×4=12」という計算を実行し、答えの「12」を@<b>{レスポンス}としてクライアントに返送します。その結果、クライアントのブラウザに「12」という文字が表示されます。

つまりSSRでは「3×4=12」という計算をサーバ側で実行しています。そのため、処理速度はサーバのスペックに依存します。

==== Client Side Rendering (CSR)